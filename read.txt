////main.py
from pydantic import BaseModel
from fastapi import FastAPI, status, HTTPException, Depends
from sqlalchemy.orm import Session
from .database import SessionLocal
from . import models
from fastapi.params import Body

app = FastAPI()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get('/sql')
def sql_test(db: Session = Depends(get_db)):
    posts = db.query(models.Post).all()
    # posts = db.query(models.Post) # print post sql query
    return {"status":posts}

# @app.post('/post')
# def post(info:dict=Body(), db: Session = Depends(get_db)):
#     new_post = models.Post(title = info['title'], content=info['content'], published=info['published'])
#     db.add(new_post)
#     db.refresh(new_post)
#     return {"status":new_post}

class Data(BaseModel):
    title:str
    content:str
    published:int

@app.post('/post')
def post(info:Data, db : Session = Depends(get_db)):
    # print(info.dict())
    # new_post = models.Post(title=info.title, content=info.content, published=int(info.published))
    new_post = models.Post(**info.dict())
    
    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return {"message":new_post}

////database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = 'mysql+mysqlconnector://fastapi:fast123@localhost/fastapi'

engine = create_engine(SQLALCHEMY_DATABASE_URL)
connection = engine.connect()


Base = declarative_base()
Base.metadata.create_all(bind=engine)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)



////models.py

from sqlalchemy import Column,Integer,Boolean,VARCHAR,TIMESTAMP,CheckConstraint
from sqlalchemy.sql.expression import null, text
from  .database import Base
class Post(Base):
    __tablename__ = 'posts'
    id = Column(Integer, primary_key=True, nullable=False)
    title = Column(VARCHAR(100), nullable=False)
    content = Column(VARCHAR(100), nullable=False)
    published = Column(Boolean, server_default=text('TRUE'), nullable=False)
    created_at = Column(TIMESTAMP(timezone=True), server_default=text('NOW()'))




# from typing import Optional
# from fastapi import FastAPI, status, HTTPException
# from fastapi.params import Body
# from pydantic import BaseModel
# import mysql.connector

# # Registration class
# class reg(BaseModel):
#     f_name:str
#     l_name:str
#     email:str
#     pwd:str
#     status:Optional[bool]=False

# # Login cred
# class cred(BaseModel):
#     user_id:int
#     email:str
#     pwd:str

# app = FastAPI()
# con = mysql.connector.connect(username="fastapi", host="localhost")
# mydb = con.cursor(buffered=True)

# mydb.execute("SHOW DATABASES")

# mydb.execute('USE fastapi')
# # mydb.execute('SHOW TABLES')
# mydb.execute('INSERT INTO user_info VALUES(%s,%s,%s,%s,%s)',(4,"rakesh","singh","rk@33gmail.com","fsdfs"))
# con.commit()
# mydb.execute('SELECT * FROM user_info')


# @app.get('/userdata')
# def userdata():
#     mydb.execute('USE fastapi')
#     mydb.execute('SELECT * FROM user_info')
#     fdata = mydb.fetchall()
#     return {"message":f" {fdata}"}

# @app.post('/signup')
# def signup(info:reg):
#     return {"message":"success"}
    



from typing import Optional
from fastapi import FastAPI, HTTPException, status
from fastapi.params import Body
from pydantic import BaseModel
import mysql.connector

class User(BaseModel):
    id:int 
    first_name:str
    last_name:str
    email:str
    passwd:str
    status:Optional[bool]=False

data = {}

con = mysql.connector.connect(host='localhost', user='fastapi')
mydata = con.cursor(buffered=True)
mydata.execute("SHOW DATABASES")
mydata.execute("USE fastapi")
mydata.execute("SHOW TABLES")
mydata.execute("DESC user_info")
mydata.execute("INSERT INTO user_info VALUES(%s,%s,%s,%s,%s)",(1,'aman', 'khan', 'ak722442@gmail.com', 'qwerty'))
con.commit()
# print(mydata.fetchall())
app = FastAPI()


def check(new):
    if(len(new.first_name)==0 or len(new.last_name)==0 or len(new.email)==0 or len(new.passwd)==0):
        return False
    return True

def checkCred(cred):
    if(data.get(cred['id'])!=None):
        if(data[cred['id']]['email']==cred['email'] and data[cred['id']]['pwd']==cred['pwd']):
            return True
    return False
    

@app.post('/signup',status_code=status.HTTP_201_CREATED)
def signUp(info: User):
    if(check(info)==False):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid Information")
    else:
        data[info.id] = {"full_name":info.first_name+" "+info.last_name, "email":info.email, "pwd":info.passwd, "status":info.status}
        return {"message": f"{info.first_name} {info.last_name}, your account is created"}

@app.post('/login')
def signin(cred:dict=Body()):
    if(checkCred(cred)==False):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid Credentials")
    else:
        data[cred['id']]['status']=True
        return {"message": f"{data[cred['id']]['full_name']},  logged In"}
